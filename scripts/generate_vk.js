#!/usr/bin/env node

/**
 * Generate Rust Groth16 verification key constants from snarkjs verification_key.json files.
 */
const fs = require('fs');
const path = require('path');

const CIRCUITS = [
  { dir: 'age_proof', constName: 'AGE_PROOF' },
  { dir: 'nationality_proof', constName: 'NATIONALITY_PROOF' },
  { dir: 'passport_verifier', constName: 'PASSPORT_VERIFIER' },
];

const CIRCUITS_ROOT = path.resolve(__dirname, '..', 'circuits');
const OUTPUT_PATH = path.resolve(
  __dirname,
  '..',
  'programs',
  'zassport',
  'src',
  'zk_verifier',
  'verification_keys.rs'
);

const BN254_PRIME = BigInt(
  '21888242871839275222246405745257275088548364400416034343698204186575808495617'
);

function toBytesBE(value) {
  let num = BigInt(value);
  if (num < 0n) {
    num = (num % BN254_PRIME + BN254_PRIME) % BN254_PRIME;
  }
  const bytes = new Array(32).fill(0);
  for (let i = 31; i >= 0 && num > 0n; i--) {
    bytes[i] = Number(num & 0xffn);
    num >>= 8n;
  }
  if (num !== 0n) {
    throw new Error('Field element does not fit in 32 bytes');
  }
  return bytes;
}

function g1ToBytes(point) {
  // Big-endian limbs for G1 (x,y)
  return [...toBytesBE(point[0]), ...toBytesBE(point[1])];
}

function g2ToBytes(point) {
  const x = point[0];
  const y = point[1];
  // Alt order (c1,c0) for x and y, big-endian per 32-byte limb
  return [
    ...toBytesBE(x[1]),
    ...toBytesBE(x[0]),
    ...toBytesBE(y[1]),
    ...toBytesBE(y[0]),
  ];
}

// No endianness flipping needed; we emit big-endian byte arrays expected by the verifier.

function formatArray(bytes, indent = 4, perLine = 16) {
  const chunks = [];
  for (let i = 0; i < bytes.length; i += perLine) {
    const slice = bytes.slice(i, i + perLine);
    chunks.push(
      `${' '.repeat(indent)}${slice.map((b) => b.toString()).join(', ')}${i + perLine >= bytes.length ? '' : ','}`
    );
  }
  return chunks.join('\n');
}

function generateVkConst({ dir, constName }) {
  const vkPath = path.join(CIRCUITS_ROOT, dir, 'build', 'verification_key.json');
  const data = JSON.parse(fs.readFileSync(vkPath, 'utf8'));

  const alpha = g1ToBytes(data.vk_alpha_1);
  const beta = g2ToBytes(data.vk_beta_2);
  const gamma = g2ToBytes(data.vk_gamma_2);
  const delta = g2ToBytes(data.vk_delta_2);
  const ic = data.IC.map((point) => g1ToBytes(point));

  return {
    constName,
    nPublic: data.nPublic,
    alpha,
    beta,
    gamma,
    delta,
    ic,
  };
}

function renderVkModule(records) {
  let out = '';
  out += '// AUTO-GENERATED BY scripts/generate_vk.js. DO NOT EDIT MANUALLY.\n';
  out += '// This file embeds Groth16 verification keys for all circuits.\n\n';
  out += "use groth16_solana::groth16::Groth16Verifyingkey;\n\n";

  for (const record of records) {
    out += `pub const ${record.constName}_IC: [[u8; 64]; ${record.ic.length}] = [\n`;
    record.ic.forEach((bytes, index) => {
      out += `    [\n${formatArray(bytes, 8)}\n    ]${index === record.ic.length - 1 ? '' : ','}\n`;
    });
    out += '];\n\n';

    out += `pub const ${record.constName}_VK: Groth16Verifyingkey<'static> = Groth16Verifyingkey {\n`;
    out += `    nr_pubinputs: ${record.nPublic},\n`;
    out += '    vk_alpha_g1: [\n';
    out += `${formatArray(record.alpha, 8)}\n`;
    out += '    ],\n';
    out += '    vk_beta_g2: [\n';
    out += `${formatArray(record.beta, 8)}\n`;
    out += '    ],\n';
    out += '    vk_gamme_g2: [\n';
    out += `${formatArray(record.gamma, 8)}\n`;
    out += '    ],\n';
    out += '    vk_delta_g2: [\n';
    out += `${formatArray(record.delta, 8)}\n`;
    out += '    ],\n';
    out += `    vk_ic: &${record.constName}_IC,\n`;
    out += '};\n\n';
  }

  return out;
}

function main() {
  const records = CIRCUITS.map(generateVkConst);
  const moduleSource = renderVkModule(records);
  fs.writeFileSync(OUTPUT_PATH, moduleSource);
  console.log(`âœ… Wrote verification keys to ${path.relative(process.cwd(), OUTPUT_PATH)}`);
}

main();
