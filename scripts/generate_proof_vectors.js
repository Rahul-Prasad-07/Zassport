#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

const CIRCUITS = [
  { dir: 'age_proof', name: 'AGE', public: 5 },
  { dir: 'nationality_proof', name: 'NATIONALITY', public: 3 },
  { dir: 'passport_verifier', name: 'PASSPORT', public: 5 },
];

const CIRCUITS_ROOT = path.resolve(__dirname, '..', 'circuits');
const OUTPUT_PATH = path.resolve(
  __dirname,
  '..',
  'programs',
  'zassport',
  'src',
  'zk_verifier',
  'test_vectors.rs'
);

const BN254_PRIME = BigInt(
  '21888242871839275222246405745257275088548364400416034343698204186575808495617'
);

function toBytesBE(value) {
  let num = BigInt(value);
  if (num < 0n) {
    num = (num % BN254_PRIME + BN254_PRIME) % BN254_PRIME;
  }
  const bytes = new Array(32).fill(0);
  for (let i = 31; i >= 0 && num > 0n; i--) {
    bytes[i] = Number(num & 0xffn);
    num >>= 8n;
  }
  if (num !== 0n) {
    throw new Error('Field element does not fit in 32 bytes');
  }
  return bytes;
}

function g1ToBytes(point) {
  // Keep raw snarkjs format (no negation in fixtures - will be done on-chain if needed)
  return [...toBytesBE(point[0]), ...toBytesBE(point[1])];
}

function g2ProofToBytes(point) {
  const x = point[0];
  const y = point[1];
  // Alt order (c1,c0) and big-endian per 32-byte limb to match on-chain verifier
  return [
    ...toBytesBE(x[1]),
    ...toBytesBE(x[0]),
    ...toBytesBE(y[1]),
    ...toBytesBE(y[0]),
  ];
}

function formatArray(bytes, indent = 4, perLine = 16) {
  const chunks = [];
  for (let i = 0; i < bytes.length; i += perLine) {
    const slice = bytes.slice(i, i + perLine);
    chunks.push(
      `${' '.repeat(indent)}${slice.map((b) => b.toString()).join(', ')}${i + perLine >= bytes.length ? '' : ','}`
    );
  }
  return chunks.join('\n');
}

function formatPublicInputs(arr) {
  const segments = arr.map((bytes, idx) => {
    return `    [\n${formatArray(bytes, 8)}\n    ]${idx === arr.length - 1 ? '' : ','}`;
  });
  return segments.join('\n');
}

function loadCircuitData(dir) {
  const proofPath = path.join(CIRCUITS_ROOT, dir, 'build', 'proof.json');
  const publicPath = path.join(CIRCUITS_ROOT, dir, 'build', 'public.json');

  const proof = JSON.parse(fs.readFileSync(proofPath, 'utf8'));
  const pub = JSON.parse(fs.readFileSync(publicPath, 'utf8'));

  const proofBytes = [
    ...g1ToBytes(proof.pi_a),
    ...g2ProofToBytes(proof.pi_b),
    ...g1ToBytes(proof.pi_c),
  ];

  if (proofBytes.length !== 256) {
    throw new Error(`Unexpected proof byte length for ${dir}`);
  }

  const publicBytes = pub.map((value) => toBytesBE(value));

  return { proofBytes, publicBytes };
}

function renderModule(records) {
  let out = '';
  out += '// AUTO-GENERATED BY scripts/generate_proof_vectors.js. DO NOT EDIT MANUALLY.\n';
  out += '// Test fixtures with Groth16 proofs and public inputs derived from circuits.\n\n';

  records.forEach(({ name, proofBytes, publicBytes }) => {
    out += `pub const ${name}_PROOF_BYTES: [u8; 256] = [\n`;
    out += `${formatArray(proofBytes, 4)}\n`;
    out += `];\n\n`;
    out += `pub const ${name}_PUBLIC_INPUTS: [[u8; 32]; ${publicBytes.length}] = [\n`;
    out += `${formatPublicInputs(publicBytes)}\n`;
    out += `];\n\n`;
  });

  return out;
}

function main() {
  const records = CIRCUITS.map(({ dir, name }) => {
    const { proofBytes, publicBytes } = loadCircuitData(dir);
    return { name, proofBytes, publicBytes };
  });

  const moduleSource = renderModule(records);
  fs.writeFileSync(OUTPUT_PATH, moduleSource);
  console.log(`âœ… Wrote proof fixtures to ${path.relative(process.cwd(), OUTPUT_PATH)}`);
}

main();
